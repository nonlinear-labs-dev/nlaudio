http://askubuntu.com/questions/51283/how-to-run-a-program-with-sched-rr-policy-from-command-line

sudo chrt --rr 99 ./nlaudio

1. Alsa Output Teil sauber abschliessen:
    - Kleinigkeiten fertig machen
    - Beispielprogramm, wie es zu nutzen ist.
    - Idiotensicher
3. Implementation mit Jack Input und Output


Midi:

Erstmal nicht sample akkurat, (DirektMidi) und danach ev. Mit Jack oder so mal schauen.



//

#if 0
        CircularAudioBuffer<long> cBuffer(4096);
        auto writerFunc = [](CircularAudioBuffer<long> *cBuffer){
                const long buffersize = 256;

                long b[buffersize];

                for (int i=0; i<buffersize; i++)
                        b[i] = i;

                while (1) {
                        cBuffer->set(b, buffersize);
                        for(int i=0; i<buffersize; i++)
                                b[i] += buffersize;

                        std::this_thread::sleep_for(std::chrono::milliseconds(1));
                }
        };


        auto readerFunc = [](CircularAudioBuffer<long> *cBuffer){
                const long buffersize = 512;

                long b[buffersize];

                while (1) {
                        cBuffer->get(b, buffersize);
                        for(int i=0; i<buffersize; i++)
                                std::cout << "read: " << b[i] << std::endl;

                        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
                }
        };

        std::thread t1(writerFunc, &cBuffer);
        std::thread t2(readerFunc, &cBuffer);



        while(1);

        return 0;

#endif


#if DEBUG_MIDI
                auto readMidi = [](std::shared_ptr<BlockingCircularBuffer<char>> buffer) {

                        const int buffersize = 3;
                        char b[buffersize];

                        while(1) {
                                buffer->get(b, buffersize);
                                for (int i=0; i<buffersize; i++)
                                        printf("%02X ", b[i]);

                                printf("\n");
                        }
                };
                std::thread midiThread(readMidi, midiBuffer);
#endif //DEBUG_MIDI


#if 0
#define DEBUG_MIDI 1

        try {
                // MIDI
                std::string firstDevice = NlRawMidiDevice::getFirstDevice();

                if (firstDevice.size()) {
                        std::cout << "Opening first midi device: " << firstDevice << std::endl;
                } else {
                        std::cout << "Please connect a midi device first." << std::endl;
                        exit(-1);
                }

                std::shared_ptr<BlockingCircularBuffer<unsigned char>> midiBuffer(new BlockingCircularBuffer<unsigned char>(30));
                NlRawMidiDevice *midi = new NlRawMidiDevice(firstDevice, midiBuffer);
                midi->open();

                auto readMidi = [](std::shared_ptr<BlockingCircularBuffer<unsigned char>> buffer) {

                                const int buffersize = 3;
                                unsigned char b[buffersize];

                                while(1) {
                                                buffer->get(b, buffersize);
                                                for (int i=0; i<buffersize; i++)
                                                                printf("%02X ", (unsigned char)b[i]);

                                                printf("\n");
                                }
                };
                std::thread midiThread(readMidi, midiBuffer);
                midi->start();

                char *nextBuffer = nullptr;

                // Audio
                std::shared_ptr<BlockingCircularBuffer<char>> audioBuffer(new BlockingCircularBuffer<char>(4096));
                NlAudioAlsaOutput alsaoutput("hw:0,0", audioBuffer);
                alsaoutput.open();
                alsaoutput.setSampleFormat("S16_LE");
                alsaoutput.setBufferCount(2);
                alsaoutput.setBuffersize(128);
                alsaoutput.setChannelCount(2);
                alsaoutput.start();

                auto writeAudio = [](std::shared_ptr<BlockingCircularBuffer<char>> audioBuffer) {

                        const int samplerate = 44100;
                        const int buffersize = 128;
                        char silenceBuffer[buffersize];
                        char sineBuffer[buffersize];
                        char midiData[3];

                        memset(silenceBuffer, 0, buffersize);

                        while(1) {
                                //if (midiBuffer->availableToRead() >= 3) {
                                        //midiBuffer->get(midiData, 3);
                                        //if (midiData[0] == 0x90) { //NoteOn
                                                generateSin(sineBuffer, buffersize, 440, samplerate, 2);
                                        //	nextBuffer = sineBuffer;
                                        //} else if (midiData[1] == 0x80) { //NoteOff
                                        //	nextBuffer = silenceBuffer;
                                        //}
                                //} else {
                                //	nextBuffer = silenceBuffer;
                                //}

                                // Blocks until there is storage.
                                audioBuffer->set(sineBuffer, buffersize);
                        }
                };

                std::thread audioThread(writeAudio, audioBuffer);



                // Wait for user to exit by pressing 'q'
                char exitKey = 0;
                while(exitKey != 'q') {
                        std::cout << "Alsa Output Statistics:" << std::endl;
                        //std::cout << alsaoutput.getStats();
                        exitKey = getchar();
                }

        } catch (const std::exception& exception) {
                std::cout << "GrepMe1 " << exception.what() << std::endl;
        }
#endif


void printInfos(const AudioAlsa& device)
{
        auto sampleFormats = device.getAvailableSampleformats();

        std::cout << "Sample Formats[" << sampleFormats.size() << "]:" << std::endl;

        for (auto it = sampleFormats.begin(); it != sampleFormats.end(); ++it)
                std::cout << "  " << *it << std::endl;

}
